-  java编译器更加严格,不允许把高类型的变量赋值给低类型,会直接报错,如
```
long l=1;
int i=l;
```

 但是c++编译器允许这种转换,虽然会损失精度,而且没有警告
如何区分高类型与低类型: 该类型表示数的范围越大,类型越高(不是通过占用内存大小来判断的),		因此float>long
[注意]java有个奇怪的特性,short,byte,char三个类型在做运算时会自动转化成int,所以形如
```
short s1=1,s2=2;
short s3=s1+s2;
```
-是不靠谱的!,并且他们三种类型相互不可转化,可以理解为:java希望我们通过int作为中间人来转化常用的类型
但是使用强制类型转换,就不会有问题
深入理解: 形如以下赋值:
```
long l=12345;
```

没有在12345后面加上"L"编译器会把它看成是int型,在java和c编译器上都适用
但是在gcc 8.2.0-3里,int_max和long_max的值是一样的
但是注意别钻牛角尖:
```
char c=97;
short s=21;
byte b=13;
```
这种初始化表达式是可以通过的,编译器会在这里放宽标准,不然我们就没办法为变量赋值了!
与之对应的
```
int i=97;
char c=i;
```
则不能通过编译

> 
> 
> 查阅资料:
> 32位系统：long是4字节32位，int是4字节32位。
> 64位系统：long是8字节64位，int是4字节32位。
> 疑惑:我的电脑是64位,但是结果却和32位一样,我先假设没有被无量商家坑害,合理的解释是我的编译器MinGW是基于32位设计的,下面引用我找到的资料:
> 试试问答体。首先得绕个远路，从Win32开始说起，否则之后容易乱……
> Q：什么是Win32？
> A：嘛，32自然是指32位了？不一定。
> 正式地说，Win32主要是指跑在Windows NT内核上的Win32子系统。现在x64的Windows上的大部分程序也是跑在这个子系统上的，system32目录也没叫成system64。
> 尽管32的语源的确来自于“32位”。
> Q：那么为什么还有Win64？
> 这倒可以肯定，这里的64是指64位目标平台，因为没有上面的那种歧义。
> 有一点值得注意，在MSVC中，32位环境（当然是说跑的Intel 兼容CPU的PC）预定义宏_WIN32，但64位环境同时预定义了_WIN32和_WIN64。
> 顺便，通常64位主要指x86_64（微软称为AMD64，这个兼容x86的基础架构一开始的确是AMD先搞出来的，后来才有Intel EM64T）。
> 64位Itanium也有_WIN64，不过一般见不到且跟MinGW没什么关系且现在都不正式支持了，不管了……
> 对于MinGW来说，这里也有类似的坑：预定义宏得先优先检查64位的。实际情况更加复杂，另说。
> Q：MinGW和MinGW-W64有什么区别？
> 这个是个关键问题，但是……是个很长的故事。没有铺垫不好回答。
> 首先，MinGW是GNU工具（包括编译器GCC和GNU binutils和调试器GDB等）在Win32上的一个移植，是从Cygwin里fork出来的。当初只考虑32位。和Cygwin相比，不强调POSIX兼容性而相对强调性能和减小依赖。
> 具体来说MinGW除了以上工具外，还提供了一个适配于Win32的运行时环境。其中C标准库实现用的直接是微软随Windows分发的MSVCRT。MinGW自己的运行时库依赖于MSVCRT和其它系统库。
> 而MinGW GCC依赖于MinGW运行时以及libgcc和其它系统库。编译出来的程序一般也要依赖这些库，所以才会写死在默认specs里（可以用gcc -dumpspecs查看）免得用户随便编译链接个程序还得手动指定一大堆-l选项。
> 用三元组表示目标平台，当年的MinGW是指i386-pc-mingw32。这里i386也可以是i486等等……总之是32位x86指令集架构的名称。中间的pc可选，表示厂商名。mingw32表示系统名。
> 特别注意，事实上成为标准的“专有名词”mingw32里的32是固定的。另外，所有这些大小写一般也是固定的。GCC等的源码配置里面也有硬编码进去。
> 然后，因为只支持32位，有人觉得不够用。这里的一个主要人物，就是现在MinGW-W64的主要维护者Kai Tietz。因为工作需要他想MinGW提供扩充x64支持，但对方态度很不友好。于是愤而fork出来，这就是MinGW-W64的由来。
> 可见，MinGW-W64和原版MinGW有所渊源，但是独立的两个项目。
> W64虽然用意是Win64，但是也算是个专有名词，在三元组里占据厂商名，例如常见的：i686-w64-mingw32。（在GCC源码的配置文件中，*-w64-mingw32和*-pc-mingw32是分别对待的。）
> MinGW-W64是同时支持32位和64位的。甚至还支持32位和64位的交叉编译（启用multilib支持的MinGW发行版例如mingw-builds可以用-m32或-m64指定）。
> 显然，W64和支持的架构无关。上面i686就不是64位的平台（而且可以看出这里的32也和架构没关系）。支持64为的对应三元组是x86_64-w64-mingw32。
> ……容易让人头疼的是，这两个项目现在都没死，偏偏还很容易因为这些字面上的原因搞错。为了下文描述方便，原版MinGW称为MinGW.org。
> 这里有一点非常重要：只有MinGW-W64是GCC官方支持的（尽管mingw32平台是二等公民）。Kai Tietz拥有GCC官方repo的提交权限。
> 所以，使用MinGW-W64的GCC一般比MinGW.org有更新更全面的支持，所以现在一般推荐MinGW-W64发行版。
> 说到这里……维护mingw.org的Keith Marshall还和Kai Tietz等GCC官方人员在bugzilla上对噗过：gcc.gnu.org/bugzilla/show_bug.cgi?id=52015。
> 其中Keith Marshall对MinGW-W64使用MinGW一名造成混淆表示愤慨。嘛，这倒也是事实。
> 当然，也不是说MinGW.org就一无是处了。*-w64-mingw32原则上向后兼容*-pc-mingw32，不过也有一些接口上的差别。BSD流的DT_*在MinGW.org上能用，在MinGW-W64的就没有。（虽然DT_*也不怎么推荐用就是了……）
> Q：什么是MinGW发行版(distribution) ？
> 这个说法习惯上可以说是从Linux等软件中借用过来的。
> 类似Linux内核，不管MinGW.org还是MinGW-W64，本身都是相对集中于特定软件包（MinGW运行时库）开发的项目，并不着力于提供整个开箱即用的环境。
> 因此除了官方的一些编译版本外，有很多人基于MinGW运行时上进行定制封装供用户下载整个环境，有的还提供包管理服务等。这就是发行版。一般提供直接解压加上PATH就能用的环境和/或安装包。
> 早期比较著名的有TDM-GCC、rubenvb等。
> 以前用的MinGW.org，不过现在主要转到MinGW-W64上来了。
> 比较新的发行版，一开始就着眼于MinGW-W64。最著名的发行版之一应该是mingw-builds，基本上近年来（GCC4.7以后）Windows上能用支持最新版本最快的，支持交叉编译。
> mingw-builds一开始在sf.net上有自己的项目，不过后来表示要求加入MinGW-W64项目作为official builds，所以停更了，更新都在MinGW-W64里面，不过残念的是好像到现在MinGW-W64看来都不提供唯一的官方发行版，所以还是叫做personal builds。
> 另外提一下还有微软VC++标准库Dinkumware维护者之一Mr.STL(Stephan T. Lavavej) 个人的发行版，默认specs里加了-std=c++11。
> 还有MSYS2项目的MinGW发行版（这里可能有新的混乱，下文再说），也是mingw-builds一伙人搞的，最近（4.9.1）比mingw-builds更新还快几个小时。
> 其它发行版可以参照mingw-w64.sourceforge.net，更新相对没那么快。
> 最后，不嫌闲着蛋疼也可以自己编译。不过迫不得已外最好别这样做（GCC的编译过程和hacking实在无力吐槽）。重复一遍，非常不推荐。
> Q：上面为什么要强调更新呢？
> 如果不想使用新的特性生成更高质量的代码，其实也没必要盯着上面这么多版本混乱的MinGW了。即便要兼容性，也可以用古董嘛（逃……
> 对于C++前端来说MinGW尤为重要，现阶段根本没有能顶替的。作为系统默认ABI新锐代表的MSVC2013——前端还是残的……各种bug。
> GCC也有各种傻缺bug，不过至少在前端来说，程度上绝逼打不过cl（Microsoft C&C++ Optimizing Compiler）。
> VC++调试支持当然好得多，但是编译器一坑爹集成调试再好也没用了。
> 嘛，Clang++？libc++什么时候能在Windows上跑顺再说——即便这样MinGW兼容的还是得依赖MinGW的libgcc。至于和VC++兼容的clang-cl，看起来还在折腾微软的坑爹ABI黑箱（这没像大部分平台上GCC用的Itanium ABI公开文档），一年半载别指望了。
> Q：什么是异常模型和线程模型，用哪种比较好？
> 这两个都是对于C++实现（G++、libgcc、libsup++等等）而言的。
> 首先，异常模型。C++标准没规定异常怎么实现。MinGW GCC使用的Itanium ABI也没规定必须怎么实现（但规定了一些公共接口），这部分由实现自行考虑。
> GCC一般提供了SjLj（C的setjmp/longjmp）实现的stub。对于x86，允许使用Dwarf2调试信息的实现。两者的区别在于sjlj比较通用，但是即便不抛出捕获异常而只是使用异常中立的风格隐式传递异常，也有运行时开销。而Dwarf2兼容性（考虑多层C++和C的DLL互相调用来看）相对较差，但没有这种开销。
> 两者ABI并不兼容（知道C++坑爹了吧，不仅不同实现不兼容，同一个编译器同一个平台自己都能跟自己不兼容……）——前者依赖类似libgcc_s_sjlj.dll这样的dll，后者则是类似libgcc_s_dw2.dll这样的。旧一点的可能也没有这种后缀差异。
> 另外，libstdc++作为C++标准库实现显然依赖异常，但名字一样的dll可能依赖的不是同一种。所以混用多个版本MinGW GCC且没把path清理干净的时候容易出现找不到符号定义导致链接失败。这还不是最坑的，有时候gdb载入不同位置的dll在运行时挂掉，还不只是一个PATH的问题……这种情况下先拿system internals的process exporler之类的工具看看进程加载的DLL是不是预期的再说。
> 为什么说要有这么坑爹不兼容的，像VC++一样用一种不就好了……其实Win32 x86上最理想的应该是和VC++一样基于SEH（Windows结构化异常处理）的实现，但是Borland关于这个的专利才没过期几天……所以你懂的。
> x64上没专利的麻烦，有sjlj和SEH的实现，一般还是SEH。
> 第二，线程模型。
> Windows线程API和POSIX(pthread) 有很大不同，而ISO C++的std::thread为代表的接口是很接近pthread的。
> 所以在libstdc++上实现这些接口，首先依赖的是pthread在Win32上的移植libwinpthread，也就是POSIX线程模型。因此发布的时候需要带上libwinpthread-1.dll之类的dll。
> 至于Win32线程模型，GCC mailing list是有提过，不过到现在还是没实现。也就是说ISO C++的实现是残的，没法用。如果只打算用Win32多线程API倒是的可以用。
> 所以取决于具体需要。要兼容性好点的一般还是POSIX。
> Q：什么是MSYS，和MinGW有什么区别？
> MSYS是提供一套“系统”，三元组是*-pc-msys。
> 和MinGW相比，MSYS更接近Cygwin（强调POSIX兼容性），提供了一个sysroot（下面有/bin啊/etc什么的），因此移植POSIX环境的程序一般更方便。
> 代价也是有的。MSYS环境下原生编译的程序一般需要多依赖MSYS运行时库（当然比Cygwin要轻量多了）。
> 所以常规的实践是，如果只是开发Windows程序，能用MinGW就不要用MSYS原生的编译器来构建。当然，使用MSYS上的sh等工具还是没问题，跟GNU工具配套怎么说比cmd总好用。（虽然也有不少琐碎坑爹bug。）
> Q：什么是MSYS2，MSYS2上的MinGW发行版是怎么回事？
> 字面意思，MSYS 2.0。比起1.0来说更加像Cygwin（例如/etc/fstab配置）。项目在sf.net上托管。
> 一个特色是基础系统附带ArchLinux移植的包管理器pacman，可以同时独立部署/mingw32（i686-w64-mingw32）和/mingw64（x86-w64-mingw32）下的开发和运行环境。
> 下载依赖相当方便（就是没有靠谱的镜像，网速可能非常拙计）。具体使用参考ArchLinux Wiki。
> 虽然不支持交叉编译，不过可以分别装所以不是什么问题，比mingw-builds的-m32和-m64来说更加稳定靠谱。
> 只提供Dwarf2异常模型和POSIX线程模型对于成套系统也不是什么大问题。包虽然比不上ArchLinux那么丰富不过常用的很多都有，免去自己编译的麻烦。打算长期使用MinGW和相关工具的，推荐使用。
> 虽然滚挂了也没多大事，不过版本是个问题。如果需要特定版本的GCC就不适用（比如规避GCC 4.9的坑爹bug……），除非有耐心自己找到.xz手动安装。
> Q：部署程序需要提供哪些文件？
> Windows默认安装自然不带MinGW运行时环境，所以除了编译出来的程序和可能附带的数据，一些dll是要准备好的——除非有耐心折腾全部静态链接。
> 不同版本不同语言不同编译器编译出来的东西都不太一样。最简单暴力也可靠（？）的方法就是复制可执行程序到没装环境的白板测试机上看少了哪些东西（不过未必一目了然）。
> 简单可靠的方式是用Dependency Walker等工具查看依赖。
> 对于C++，除非不用POSIX thread可以省掉libwinpthread，一般至少得确保上面异常模型和线程模型讨论中提到的三个dll（注意就算你不显示使用标准库，编译器生成的代码也可能用到——典型的如默认::operator new，所以得带上libstdc++）。
> Q：现在还有什么新坑？
> 就提一个GCC 4.9的问题。
> GCC 4.9的LTO（链接时优化）默认使用新的目标文件格式，生成的文件不包含冗余的二进制代码。
> 但是LTO有特定的phase（内部会多编译几个pass），传统的静态链接器(ar) 不知道这里的约定，所以原来好好的东西，升级4.9以后开了-flto就可能找不到符号链接失败。
> 现在MinGW发行版应该都没实现gcc-ar（运行会提示没支持linker plugin）。兼容旧版本的行为还得加上-ffat-lto-objects编译选项。

- 此外形如:

`float f=1.2;`


在c++中能通过编译,但java不行,这是因为1.2默认是double类型,C++隐式转换成了float,再次说明了java编译器的严格,同时我也明白了一点为什么Linus要骂C++和C++程序员

在java和c++中,char类型不允许为空,string类型允许为空

```
char c='';//wrong
string s="";//right
```


- java中的boolean类型几乎只能和boolean,string两种类型做运算
而c++会把非0的数视为true,反之false

java中string类型可以和所有基本类型做连接(+)操作
```
string s=1+2+"hello";
string s2="hello"+1+2;
```

上述结果s=3hello,s2=hello12
也就是说string连接操作根据顺序确定运算类型
char之间的+运算会被提升成int运算
深入理解:
运算会用到堆栈,因此有运算符之间优先级的问题,类比之前写的计算器小程序,可以发现,当第二个加号入栈时,前面的加法(连接)因为优先级相等因此先运算了,根据两个运算数的类型决定运算重载.

- 基本类型不能直接提升成string类型,如:
```
string s=1;
string s2=(short)1;
string s3=(boolean)true;
```
因此连接操作是把基本类型先string化

- 不同进制可以直接运算

`int a=0b1011+0x12f0+014+25;`


- java支持对char类型直接赋值汉字,c++需要使用wchar_t
在linux内置了gbk,而MinGW32没有,所以仍然会出现乱码,从这里可以看出移植性的差别

前面提到java中short,byte,char之间的运算都会提升成int,但是形如:
```
short s=12;
s+=3;
char c='a';
c+=5;
```
不会改变原有的类型

- java中&(逻辑与),&&(短路与)都可以用于bool判断,但同时,&,|可以用于byte 类型的运算
对于两数^(异或),c++不可以直接用cout输出
区别是：逻辑与会把两个值都切实执行一次，而短路与一旦能确定bool值，就不再运算,或运算同理

- java的scanner类提供了细致的输入功能,与c++的流输入不同,输入时必须制定类型,接近c中的scanf,这也体现了"在java中一切皆是类"

- java字符串的索引功能使用内部方法charAt(i)
String s="12345";
char c=s.charAt(1);

    c++则直接使用下标操作
- java文件直接编译过后就成为一个类(class),在同一个文件夹下可以直接调用别的类的接口

- java允许声明数组而不定义
```
int[] a;
a=new int[] {1,2,3};
```

c++在声明时必须定义;
这样看的话上面int[] a类似于c++中的int*a;


- java数组类型是boolean时默认初始化为false,其他所有数值型基本类型初始化都为0

- 由java内存回收机制引发的思考
在高级语言中,创建者的工作是尽力让底层的机制对程序员不可见,例如java会把没办法索引到的内存空间给回收掉(比如数组指针位置改变导致):
int[]a=new int[3];
a=new int[4];//这就导致原先分配的数组丢失


- java和c++中都可以在数组声明时赋值
```
int a[3]={1,2,3};//类型推断,静态初始化
a={2,4,6};//出错 静态初始化只能在声明的时候调用
//下面的用法仅限java
int b[];//c++不允许不指定长度的数组申请,除非动态申请
b=a;//c++不允许一个数组名给另一个数组名,因为数组名不是左值(可以用指针代替)
```

java中可以这样声明数组:
```
int[] a;//一位数组
int[] a[];//二维数组
int a[][];//二位数组
//以此类推
//但不能这样
int a[3];
```
结合上述差别,可以总结出:

1.java数组中的[]类似于一个标记,用于声明这是个数组,不能在里面直接填写数组长度,需要一个构造函数来赋值给它

2.c++中为[]添加了一些功能,比如

`int a[3];`

就可以直接申请3个int长度的数组并赋给a
而java中
int a[];

则只会声明而不会初始化,此时a是不可以调用的,需要先初始化
因此java变量声明的时候一定要初始化

3.java动态初始化时不能指定维数,只有静态初始化可以
```
int a[][]=new int [][]{{1,2},{1,2}};//对,也可以写成
int a[][]={{1,2},{1,2}};//对
int a[][]=new int [2][2]{{1,2},{1,2}};//错
```

c++允许在动态初始化时省略第一维的值

`int a[][2]={{1,2},{1,2},{1,3}};`

> 编译器会根据右边给出的数组自动确定维度
> 将二维数组当作参数的时候，必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。事实上，编译器是这样处理数组的：
>       设有数组int a[m][n]，如果要访问a[i][j]的值，编译器的寻址方式为：
>      &a[i][j]=&a[0][0]+i*sizeof(int)*n+j*sizeof(int); //注意n为第二维的维数，
> 因此，可以省略第一维的维数，不能省略其他维的维数。
>     在定义二维数组的时候对其进行初始化，也可以省略第一维，编译器会根据你的初始化语句自动决定第一维度。

```
int a[][][]=new int[1][][];//对
int a[][][]=new int[1][2][];//对
```

后面可以补充再次初始化.
此外java允许多维数组的每个元素长度不一样,这在C++中是不可行的

`int a[][]={{1,2},{1,2,3},{1,2,3,4,5}};//这将被看成一个二维数组`

那么为什么java可以分部初始化呢,试想一下,如果第一次只指定了数组第一维的长度,将没法确定每个元素的长度,加之java又允许不定长元素,那么合理的解释应该是:
java中只有一维数组是线性的,其他情况都保存首地址达到一种近似线性的效果,当然这话说的绝对了,应该说,"动态分配且没有一次性初始化完全的多维数组可能在内存里不是线性的",这么说严谨多了
而c++中的多维数组是真线性的,在内存中是一整块,相应地索引速度也会块于java的数组,同时也硬性要求每个元素的长度必须相等

- 今天试用了IDEA写java文件,总体给我的感觉是虽然外观没有vscode漂亮,但是调试功能和响应速度都优于vscode,相对地,它的快捷键与vscode几乎完全不同,所以提高了学习成本,不过总体的编写体验还是很好的.优于Windows下许多c++调试器非常难用,而我下载的Ubuntu20.04又有bug,还没有搜狗输入法,所以我安装了一个CentOS7的虚拟机,发现它内置的GCC版本过低,而外国镜像下载又太慢了,所以这个虚拟机不能用来调试程序,只能用作Linux的学习,相比于C++的繁杂,难以移植类似毛头小伙,java更像一个成熟稳重的大叔,所以我还会着重学一下JVM,顺便为andriod开发打打基础

- QT编译No such file or directory

> 在用Qt做记事本的时候出现：QPrinter：no such file or directory 的错误，解决方法如下：
> 在.pro文件中添加下面一行代码：
> qtHaveModule(printsupport): QT += printsupport
> 就可以了，头文件不需要改。这是因为Qt 5中将所有打印的相关类都放到了Qt Print Support模块造成的。

- 许多c++源码,乃至很大的项目都不会刻意区别int和bool类型
因为c++隐式转换的规则比较开放,这一点我觉得不是很好

- 由于java中不存在数值类型到bool类型的转换,因此java默认了一种设计规范,就是多数情况下,能得到结果的返回结果,否则返回一个负数,这里的负数就相当于c++中的0(false)
